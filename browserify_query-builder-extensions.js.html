<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.3">
  <meta charset="utf-8">
  <title>Source: browserify/query-builder-extensions.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: browserify/query-builder-extensions.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

var util = require(&#x27;./util.js&#x27;);
var asArray = util.asArray;
var isObject = util.isObject;
var extendObject = util.extendObject;

module.exports = exports = {
  /**
   * Builds a {@link http://docs.marklogic.com/guide/rest-dev/search#id_69918 combined query}
   * @memberof! MLQueryBuilder
   * @method ext.combined
   *
   * @param {Object} query - a structured query (from {@link MLQueryBuilder#where})
   * @param {String} [qtext] - a query text string, to be parsed server-side
   * @param {Object} [options] - search options
   * @return {Object} {@link http://docs.marklogic.com/guide/rest-dev/search#id_69918 combined query}
   */
  combined: function combined(query, qtext, options) {
    if ( isObject(qtext) &amp;amp;&amp;amp; !options ) {
      options = qtext;
      qtext = null;
    }

    return {
      search: {
        query: query &amp;amp;&amp;amp; query.query || query,
        qtext: qtext || &#x27;&#x27;,
        options: options &amp;amp;&amp;amp; options.options || options
      }
    };
  },

  /**
   * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_38268 &#x60;range-constraint-query&#x60;}
   * @memberof! MLQueryBuilder
   * @method ext.rangeConstraint
   *
   * @param {String} name - constraint name
   * @param {String} [operator] - operator for matching constraint to &#x60;values&#x60;; one of &#x60;LT&#x60;, &#x60;LE&#x60;, &#x60;GT&#x60;, &#x60;GE&#x60;, &#x60;EQ&#x60;, &#x60;NE&#x60; (defaults to &#x60;EQ&#x60;)
   * @param {String|Array&amp;lt;String&gt;} values - the values the constraint should equal (logical OR)
   * @param {String|Array&amp;lt;String&gt;} [options] - range options: {@link http://docs.marklogic.com/guide/rest-dev/appendixa#id_84264}
   * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_38268 range-constraint-query}
   */
  rangeConstraint: function rangeConstraint(name, operator, values, options) {
    if ( !values &amp;amp;&amp;amp; !options ) {
      values = operator;
      operator = null;
    }

    if ( operator &amp;amp;&amp;amp; [&#x27;LT&#x27;, &#x27;LE&#x27;, &#x27;GT&#x27;, &#x27;GE&#x27;, &#x27;EQ&#x27;, &#x27;NE&#x27;].indexOf(operator) === -1 ) {
      throw new Error(&#x27;invalid rangeConstraint query operator: &#x27; + operator);
    }

    return {
      &#x27;range-constraint-query&#x27;: {
        &#x27;constraint-name&#x27;: name,
        &#x27;range-operator&#x27;: operator || &#x27;EQ&#x27;,
        &#x27;value&#x27;: asArray(values),
        &#x27;range-option&#x27;: asArray(options)
      }
    };
  },

  /**
   * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_63420 &#x60;value-constraint-query&#x60;}
   * @memberof! MLQueryBuilder
   * @method ext.valueConstraint
   *
   * @param {String} name - constraint name
   * @param {String|Number|Array&amp;lt;String&gt;|Array&amp;lt;Number&gt;|null} values - the values the constraint should equal (logical OR)
   * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_63420 value-constraint-query}
   */
  valueConstraint: function valueConstraint(name, values) {
    var query = {
      &#x27;value-constraint-query&#x27;: {
        &#x27;constraint-name&#x27;: name
      }
    };

    var type;

    if (values === null) {
      type = &#x27;null&#x27;;
      values = [];
    } else {
      values = asArray(values);
      type = typeof values[0];
      type = ((type === &#x27;string&#x27;) &amp;amp;&amp;amp; &#x27;text&#x27;) || type;
    }

    query[&#x27;value-constraint-query&#x27;][type] = values;

    return query;
  },

  /**
   * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_66833 &#x60;word-constraint-query&#x60;}
   * @memberof! MLQueryBuilder
   * @method ext.wordConstraint
   *
   * @param {String} name - constraint name
   * @param {String|Array&amp;lt;String&gt;} values - the values the constraint should equal (logical OR)
   * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_66833 word-constraint-query}
   */
  wordConstraint: function wordConstraint(name, values) {
    return {
      &#x27;word-constraint-query&#x27;: {
        &#x27;constraint-name&#x27;: name,
        &#x27;text&#x27;: asArray(values)
      }
    };
  },

  /**
   * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_30776 &#x60;collection-constraint-query&#x60;}
   * @memberof! MLQueryBuilder
   * @method ext.collectionConstraint
   *
   * @param {String} name - constraint name
   * @param {String|Array&amp;lt;String&gt;} values - the values the constraint should equal (logical OR)
   * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_30776 collection-constraint-query}
   */
  collectionConstraint: function collectionConstraint(name, values) {
    return {
      &#x27;collection-constraint-query&#x27;: {
        &#x27;constraint-name&#x27;: name,
        &#x27;uri&#x27;: asArray(values)
      }
    };
  },

  /**
   * Builds a {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_28778 &#x60;custom-constraint-query&#x60;}
   * @memberof! MLQueryBuilder
   * @method ext.customConstraint
   *
   * @param {String} name - constraint name
   * @param {...String|Array&amp;lt;String&gt;|Array&amp;lt;Object&gt;} values - the values the constraint should equal (logical OR)
   * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_28778 custom-constraint-query}
   */
  customConstraint: function customConstraint() {
    var args = asArray.apply(null, arguments);

    var constraintName = args.shift();

    // horrible hack for when arguments.length === 2 and arguments[1] is an array
    if ( args.length === 1 &amp;amp;&amp;amp; Array.isArray(args[0]) ) {
      args = args[0];
    }

    // args instanceof Array&amp;lt;Object&gt;
    var shouldExtend = args.map(
      function(arg) { return isObject(arg); }
    ).reduce(
      function(a, b) { return a &amp;amp;&amp;amp; b; }
    );

    var query = {
      &#x27;custom-constraint-query&#x27;: {
        &#x27;constraint-name&#x27;: constraintName
      }
    };

    if ( shouldExtend ) {
      while ( args.length ) {
        extendObject(query[&#x27;custom-constraint-query&#x27;], args.shift());
      }
    } else {
      query[&#x27;custom-constraint-query&#x27;].text = args.filter(function(arg) {
        return !isObject(arg);
      });
    }

    return query;
  },

  /**
   * Helper method: builds an object of &#x60;points&#x60;, &#x60;boxes&#x60;, &#x60;circles&#x60;, and &#x60;polygons&#x60;,
   * used by {@link MLQueryBuilder.ext.geospatialConstraint}, for use with
   * {@link MLQueryBuilder.ext.customConstraint}
   *
   * examples:
   *
   *   &#x60;&#x60;&#x60;
   *   qb.ext.geospatialConstraint(&#x27;name&#x27;,
   *     { latitude: 1, longitude: 2 },
   *     { south: 1, west: 2, north: 3, east: 4 }
   *   );
   *   &#x60;&#x60;&#x60;
   *
   *   &#x60;&#x60;&#x60;
   *   qb.ext.customConstraint(&#x27;name&#x27;, qb.ext.geospatialValues(
   *     { latitude: 1, longitude: 2 },
   *     { south: 1, west: 2, north: 3, east: 4 }
   *   ));
   *   &#x60;&#x60;&#x60;
   *
   * @memberof! MLQueryBuilder
   * @method ext.geospatialValues
   *
   * @param {...Object} values - the geospatial values to parse
   * @return {Object} parsed geospatial values
   */
  geospatialValues: function geospatialValues() {
    var shapes = asArray.apply(null, arguments);

    var points = [];
    var boxes = [];
    var circles = [];
    var polygons = [];
    var shape;

    for (var i = 0; i &amp;lt; shapes.length; i++) {
      shape = shapes[i];

      if (shape.latitude) {
        points.push(shape);
      } else if (shape.south) {
        boxes.push(shape);
      } else if (shape.radius) {
        circles.push(shape);
      } else if (shape.point) {
        polygons.push(shape);
      }
    }

    return {
      point: points,
      box: boxes,
      circle: circles,
      polygon: polygons
    };
  },

  /**
   * builds a [geospatial-constraint-query](http://docs.marklogic.com/guide/search-dev/structured-query#id_88775)
   * @memberof! MLQueryBuilder
   * @method ext.geospatialConstraint
   *
   * @param {String} name - constraint name
   * @param {...Object} values - the geospatial values to parse
   * @return {Object} [geospatial-constraint-query](http://docs.marklogic.com/guide/search-dev/structured-query#id_88775)
   */
  geospatialConstraint: function geospatialConstraint() {
    var args = asArray.apply(null, arguments);

    var constraintName = args.shift();

    // horrible hack for when arguments.length === 2 and arguments[1] is an array
    if ( args.length === 1 &amp;amp;&amp;amp; Array.isArray(args[0]) ) {
      args = args[0];
    }

    var geoValues = this.geospatialValues.apply(this, args);

    var query = {
      &#x27;geospatial-constraint-query&#x27;: {
        &#x27;constraint-name&#x27;: constraintName
      }
    };

    extendObject(query[&#x27;geospatial-constraint-query&#x27;], geoValues);

    return query;
  },

  /**
   * constraint query function factory
   * @memberof! MLQueryBuilder
   * @method ext.constraint
   *
   * @param {String} type - constraint type (&#x60;&#x27;value&#x27; || &#x27;word&#x27; || collection&#x27; || &#x27;custom&#x27; || &#x27;*&#x27;&#x60;)
   * @return {Function} a constraint query builder function, one of:
   *   - {@link MLQueryBuilder.ext.rangeConstraint}
   *   - {@link MLQueryBuilder.ext.valueConstraint}
   *   - {@link MLQueryBuilder.ext.wordConstraint}
   *   - {@link MLQueryBuilder.ext.collectionConstraint}
   *   - {@link MLQueryBuilder.ext.customConstraint}
   */
  constraint: function constraint(type) {
    switch (type) {
      case &#x27;value&#x27;:
        return this.valueConstraint;
      case &#x27;word&#x27;:
        return this.wordConstraint;
      case &#x27;custom&#x27;:
        return this.customConstraint;
      case &#x27;collection&#x27;:
        return this.collectionConstraint;
      default:
        return this.rangeConstraint;
    }
  },

  /**
   * Builds an {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_45570 &#x60;operator-state&#x60; query component}
   * @memberof! MLQueryBuilder
   * @method ext.operatorState
   *
   * @param {String} name - operator name
   * @param {String} stateName - operator-state name
   * @return {Object} {@link http://docs.marklogic.com/guide/search-dev/structured-query#id_45570 operator-state query component}
   */
  operatorState: function operatorState(name, stateName) {
    return {
      &#x27;operator-state&#x27;: {
        &#x27;operator-name&#x27;: name,
        &#x27;state-name&#x27;: stateName
      }
    };
  }
};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.3 on October 15, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>